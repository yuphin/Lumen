#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#define SCENE_TEX_IDX 8
#include "gris_commons.glsl"
layout(set = 1, binding = 1) uniform accelerationStructureEXT photon_bvh;

PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);

layout(binding = 4, std430) writeonly buffer OutReservoirs { Reservoir out_reservoirs[]; };
layout(binding = 5, std430) writeonly buffer OutGBuffer { GBuffer out_gbuffers[]; };
layout(binding = 6, rgba16) writeonly uniform image2D canonical_contributions_tex;
layout(binding = 7, rgba32f) uniform image2D caustics_texture;
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer PhotonEyeDataBuffer { PhotonEyeData d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer CausticPhotonAABBs { PhotonAABB d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer CausticPhotonLightData { PhotonLightData d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer PhotonCounts { uint val; };
PhotonEyeDataBuffer photon_eye_data = PhotonEyeDataBuffer(scene_desc.photon_eye_addr);
CausticPhotonAABBs photon_aabbs = CausticPhotonAABBs(scene_desc.caustic_photon_aabbs_addr);
CausticPhotonLightData photon_light_data = CausticPhotonLightData(scene_desc.caustic_photon_light_addr);
PhotonCounts photon_counts = PhotonCounts(scene_desc.photon_count_addr);

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc.seed2);
uvec4 sampling_seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc.sampling_seed);

bool photon_is_nearby(vec3 p, vec3 photon_p, float r) {
	vec3 diff = p - photon_p;
	return dot(diff, diff) < r * r;
}

vec3 get_center(PhotonAABB aabb) { return (aabb.min + aabb.max) * 0.5; }

void main() {
	PhotonEyeData photon_eye = photon_eye_data.d[pixel_idx];
	vec3 col = vec3(0);
	if (photon_eye.primitive_instance_id.x != -1) {
		HitData photon_eye_gbuffer = get_hitdata(photon_eye.barycentrics, photon_eye.primitive_instance_id.y,
												 photon_eye.primitive_instance_id.x);
		Material photon_eye_hit_mat = load_material(photon_eye_gbuffer.material_idx, photon_eye_gbuffer.uv);
		ASSERT(is_rough(photon_eye_hit_mat));

		rayQueryEXT ray_query;

		uint ray_flags = 0;
		rayQueryInitializeEXT(ray_query, photon_bvh, ray_flags, 0xFF, photon_eye_gbuffer.pos, 0, photon_eye_gbuffer.n_s,
							  1e-8);

		bool traverse = true;
		int counter = 0;

		vec3 phi = vec3(0);
		while (traverse) {
			traverse = rayQueryProceedEXT(ray_query);
			if (!traverse) {
				break;
			}

			int photon_idx = rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, false);
			PhotonLightData photon_light = photon_light_data.d[photon_idx];

			HitData photon_hitdata = get_hitdata(photon_light.barycentrics, photon_light.primitive_instance_id.y,
												 photon_light.primitive_instance_id.x);

			bool photon_nearby = photon_is_nearby(photon_eye_gbuffer.pos, photon_hitdata.pos, pc.photon_radius);
			if (!photon_nearby) {
				continue;
			}

			bool eye_side;
			uint eye_path_length;
			bool unused;
			uint photon_path_length;
			unpack_photon_flags(photon_eye.flags, eye_side, eye_path_length);
			unpack_photon_flags(photon_light.flags, unused, photon_path_length);

			if(pc.max_depth < (eye_path_length + photon_path_length)) {
				continue;
			}

			if(dot(photon_hitdata.n_s, photon_eye_gbuffer.n_s) < 0.5) {
				continue;
			}

			vec3 wo = from_spherical(photon_eye.wo);
			vec3 wi = from_spherical(photon_light.wi);
			if(dot(photon_eye_gbuffer.n_s, wi) <= 0) {
				continue;
			}
			float cam_pdf_fwd;
			float cam_pdf_rev;
			vec3 f = eval_bsdf( photon_eye_gbuffer.n_s, wo, photon_eye_hit_mat, 1, eye_side, wi, cam_pdf_fwd, cam_pdf_rev);

			float mis_weight = 1.0 / (1.0 + photon_light.d_vm * cam_pdf_fwd);

			ASSERT(photon_light.d_vm >= 0);
			ASSERT(mis_weight >= 0);
			ASSERT(!isnan(mis_weight));
			phi += mis_weight * f * photon_light.throughput * photon_eye.throughput;
			counter++;
		}
		phi /= (PI * pc.photon_radius * pc.photon_radius * pc.num_photons);
		if(isnan(phi.x) || isnan(phi.y) || isnan(phi.z)) {
			phi = vec3(0);
		}
		col = phi;
	}
	imageStore(caustics_texture, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
}