#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#define SCENE_TEX_IDX 10
#include "gris_commons.glsl"
layout(set = 1, binding = 1) uniform accelerationStructureEXT photon_bvh;

PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);

layout(binding = 4, rgba16) writeonly uniform image2D canonical_contributions_tex;
layout(binding = 5, rgba32f) uniform image2D caustics_texture;
layout(binding = 6, std430) readonly buffer PrevPhotonReservoirs { PhotonReservoir in_reservoirs[]; };
layout(binding = 7, std430) writeonly buffer CurrPhotonReservoirs { PhotonReservoir out_reservoirs[]; };
layout(binding = 8, std430) readonly buffer PrevPhotonEyeData { PhotonEyeData prev_photon_eye_data[]; };
layout(binding = 9, std430) readonly buffer CurrPhotonEyeData { PhotonEyeData photon_eye_data[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer CausticPhotonAABBs { PhotonAABB d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer CausticPhotonLightData { PhotonLightData d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer PhotonCounts { uint val; };
CausticPhotonAABBs photon_aabbs = CausticPhotonAABBs(scene_desc.caustic_photon_aabbs_addr);
CausticPhotonLightData photon_light_data = CausticPhotonLightData(scene_desc.caustic_photon_light_addr);
PhotonCounts photon_counts = PhotonCounts(scene_desc.photon_count_addr);

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc.seed2);
uvec4 sampling_seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc.sampling_seed);

bool photon_is_nearby(vec3 p, vec3 photon_p, float r) {
	vec3 diff = p - photon_p;
	return dot(diff, diff) < r * r;
}

vec3 get_center(PhotonAABB aabb) { return (aabb.min + aabb.max) * 0.5; }

bool update_photon_reservoir(inout uvec4 seed, inout PhotonReservoir r_new, vec3 flux, vec3 pos, vec2 wi,
							 float target_pdf, float inv_source_pdf) {
	float w_i = target_pdf * inv_source_pdf;
	r_new.w_sum += w_i;
	if (rand(seed) * r_new.w_sum < w_i) {
		r_new.flux = flux;
		r_new.pos = pos;
		r_new.wi = wi;
		r_new.target_pdf = target_pdf;
		return true;
	}
	return false;
}

bool stream_photon_reservoir(inout uvec4 seed, inout PhotonReservoir r_new, vec3 flux, vec3 pos, vec2 wi,
							 float target_pdf, float inv_source_pdf) {
	r_new.M++;
	if (target_pdf <= 0.0 || isnan(inv_source_pdf) || inv_source_pdf <= 0.0) {
		return false;
	}
	return update_photon_reservoir(seed, r_new, flux, pos, wi, target_pdf, inv_source_pdf);
}

void calc_photon_reservoir_W(inout PhotonReservoir r) {
	float denom = r.target_pdf * r.M;
	r.W = denom == 0.0 ? 0.0 : r.w_sum / denom;
}

void init_reservoir(out PhotonReservoir r) {
	r.flux = vec3(0);
	r.M = 0;
	r.W = 0;
	r.w_sum = 0;
	r.target_pdf = 0;
}

void main() {
	PhotonEyeData photon_eye = photon_eye_data[pixel_idx];
	vec3 col = vec3(0);
	if (photon_eye.primitive_instance_id.x != -1) {
		HitData photon_eye_gbuffer = get_hitdata(photon_eye.barycentrics, photon_eye.primitive_instance_id.y,
												 photon_eye.primitive_instance_id.x);
		Material photon_eye_hit_mat = load_material(photon_eye_gbuffer.material_idx, photon_eye_gbuffer.uv);
		ASSERT(is_rough(photon_eye_hit_mat));

		rayQueryEXT ray_query;

		uint ray_flags = 0;
		rayQueryInitializeEXT(ray_query, photon_bvh, ray_flags, 0xFF, photon_eye_gbuffer.pos, 0, photon_eye_gbuffer.n_s,
							  1e-8);

		bool traverse = true;
		int counter = 0;

		vec3 phi = vec3(0);

		PhotonReservoir reservoir;
		init_reservoir(reservoir);

		vec3 selected_contribution = vec3(0);
		while (traverse) {
			traverse = rayQueryProceedEXT(ray_query);
			if (!traverse) {
				break;
			}

			int photon_idx = rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, false);
			PhotonLightData photon_light = photon_light_data.d[photon_idx];

			HitData photon_hitdata = get_hitdata(photon_light.barycentrics, photon_light.primitive_instance_id.y,
												 photon_light.primitive_instance_id.x);

			bool photon_nearby = photon_is_nearby(photon_eye_gbuffer.pos, photon_hitdata.pos, pc.photon_radius);
			if (!photon_nearby) {
				continue;
			}

			bool eye_side;
			uint eye_path_length;
			bool unused;
			uint photon_path_length;
			unpack_photon_flags(photon_eye.flags, eye_side, eye_path_length);
			unpack_photon_flags(photon_light.flags, unused, photon_path_length);

			if (pc.max_depth < (eye_path_length + photon_path_length)) {
				continue;
			}

			if (dot(photon_hitdata.n_s, photon_eye_gbuffer.n_s) < 0.5) {
				continue;
			}

			vec3 wo = from_spherical(photon_eye.wo);
			vec3 wi = from_spherical(photon_light.wi);
			if (dot(photon_eye_gbuffer.n_s, wi) <= 0) {
				continue;
			}
			float cam_pdf_fwd;
			float cam_pdf_rev;
			vec3 f =
				eval_bsdf(photon_eye_gbuffer.n_s, wo, photon_eye_hit_mat, 1, eye_side, wi, cam_pdf_fwd, cam_pdf_rev);

			float mis_weight = 1.0 / (1.0 + photon_light.d_vm * cam_pdf_fwd);

			ASSERT(mis_weight >= 0);
			ASSERT(!isnan(mis_weight));

			vec3 contribution = mis_weight * f * photon_light.throughput * photon_eye.throughput;

			bool merged = stream_photon_reservoir(seed, reservoir, photon_light.throughput, photon_hitdata.pos,
												  photon_light.wi, calc_target_pdf(contribution), 1.0);
			if (merged) {
				selected_contribution = contribution;
			}
			phi += contribution;
			counter++;
		}

		if (pc.total_frame_num > 0) {
			// Temporal reuse
			uint Z = reservoir.M;


			vec4 prev_pos = ubo.prev_view * vec4(photon_eye_gbuffer.pos, 1);
			prev_pos /= prev_pos.z;
			prev_pos = -ubo.prev_projection * prev_pos;
			ivec2 prev_coords = ivec2(0.5 * (1 + prev_pos.xy) * gl_LaunchSizeEXT.xy);

			if (!(any(lessThan(prev_coords, ivec2(0))) || any(greaterThanEqual(prev_coords, gl_LaunchSizeEXT.xy)))) {
				PhotonEyeData prev_photon_eye_data = prev_photon_eye_data[prev_coords.x * pc.size_y + prev_coords.y];
				if (prev_photon_eye_data.primitive_instance_id.x != -1) {
					HitData prev_photon_eye_gbuffer =
						get_hitdata(prev_photon_eye_data.barycentrics, prev_photon_eye_data.primitive_instance_id.y,
									prev_photon_eye_data.primitive_instance_id.x);
					Material prev_photon_eye_hit_mat =
						load_material(prev_photon_eye_gbuffer.material_idx, prev_photon_eye_gbuffer.uv);

					bool prev_eye_side;
					uint prev_eye_path_length;
					unpack_photon_flags(prev_photon_eye_data.flags, prev_eye_side, prev_eye_path_length);

					PhotonReservoir prev_reservoir = in_reservoirs[prev_coords.x * pc.size_y + prev_coords.y];
					vec3 wo_prev = from_spherical(prev_photon_eye_data.wo);
					vec3 wi_prev = from_spherical(prev_reservoir.wi);

					float cam_pdf_fwd_prev;
					float cam_pdf_rev_prev;
					vec3 f_prev = eval_bsdf(prev_photon_eye_gbuffer.n_s, wo_prev, prev_photon_eye_hit_mat, 1,
											prev_eye_side, wi_prev, cam_pdf_fwd_prev, cam_pdf_rev_prev);
					float mis_weight_prev = 1; // TODO
					vec3 prev_contribution = f_prev * prev_reservoir.flux * prev_photon_eye_data.throughput;

					prev_reservoir.M = min(20, prev_reservoir.M);

					float prev_contribution_pdf = calc_target_pdf(prev_contribution);

				}
			}
		}
		reservoir.M = 1;
		calc_photon_reservoir_W(reservoir);
		phi = reservoir.W * selected_contribution;
		phi /= (PI * pc.photon_radius * pc.photon_radius * pc.num_photons);

		if (isnan(phi.x) || isnan(phi.y) || isnan(phi.z)) {
			phi = vec3(0);
		}
		col = phi;
		out_reservoirs[pixel_idx] = reservoir;
	}
	imageStore(caustics_texture, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
}