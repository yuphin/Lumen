#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#define SCENE_TEX_IDX 8
#include "gris_commons.glsl"
layout(set = 1, binding = 1) uniform accelerationStructureEXT photon_bvh;

PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);

layout(binding = 4, std430) writeonly buffer OutReservoirs { Reservoir out_reservoirs[]; };
layout(binding = 5, std430) writeonly buffer OutGBuffer { GBuffer out_gbuffers[]; };
layout(binding = 6, rgba16) writeonly uniform image2D canonical_contributions_tex;
layout(binding = 7, rgba32f) uniform image2D caustics_texture;
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer PhotonEyeDataBuffer { PhotonEyeData d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer CausticPhotonAABBs { PhotonAABB d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer CausticPhotonLightData { PhotonLightData d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer PhotonCounts { uint val; };
PhotonEyeDataBuffer photon_eye_data = PhotonEyeDataBuffer(scene_desc.photon_eye_addr);
CausticPhotonAABBs photon_aabbs = CausticPhotonAABBs(scene_desc.caustic_photon_aabbs_addr);
CausticPhotonLightData photon_light_data = CausticPhotonLightData(scene_desc.caustic_photon_light_addr);
PhotonCounts photon_counts = PhotonCounts(scene_desc.photon_count_addr);

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc.seed2);
uvec4 sampling_seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc.sampling_seed);

bool photon_is_nearby(vec3 p, vec3 photon_p, float r) {
	vec3 diff = p - photon_p;
	return dot(diff, diff) < r * r;
}

vec3 get_center(PhotonAABB aabb) { return (aabb.min + aabb.max) * 0.5; }

void main() {
	PhotonEyeData photon_eye = photon_eye_data.d[pixel_idx];
	vec3 col = vec3(0);
	if (photon_eye.primitive_instance_id.x != -1) {
		HitData photon_eye_gbuffer = get_hitdata(photon_eye.barycentrics, photon_eye.primitive_instance_id.y,
												 photon_eye.primitive_instance_id.x);
		Material photon_eye_hit_mat = load_material(photon_eye_gbuffer.material_idx, photon_eye_gbuffer.uv);
		ASSERT(is_rough(photon_eye_hit_mat));

		rayQueryEXT ray_query;

		uint ray_flags = 0;
		rayQueryInitializeEXT(ray_query, photon_bvh, ray_flags, 0xFF, photon_eye_gbuffer.pos, 0, photon_eye_gbuffer.n_s,
							  1e-8);

		bool traverse = true;
		int counter = 0;

		vec3 phi = vec3(0);
		while (traverse) {
			traverse = rayQueryProceedEXT(ray_query);
			if (!traverse) {
				break;
			}

			int photon_idx = rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, false);
			PhotonLightData photon_light = photon_light_data.d[photon_idx];

			HitData photon_hitdata = get_hitdata(photon_light.barycentrics, photon_light.primitive_instance_id.y,
												 photon_light.primitive_instance_id.x);

			bool photon_nearby = photon_is_nearby(photon_eye_gbuffer.pos, photon_hitdata.pos, pc.photon_radius);
			if (!photon_nearby) {
				continue;
			}

			bool eye_side;
			uint eye_path_length;
			bool unused;
			uint photon_path_length;
			unpack_photon_flags(photon_eye.flags, eye_side, eye_path_length);
			unpack_photon_flags(photon_light.flags, unused, photon_path_length);

			if(pc.max_depth < (eye_path_length + photon_path_length)) {
				continue;
			}

			if(dot(photon_hitdata.n_s, photon_eye_gbuffer.n_s) < 0.5) {
				continue;
			}

			vec3 wo = from_spherical(photon_eye.wo);
			vec3 wi = from_spherical(photon_light.wi);
			if(dot(photon_eye_gbuffer.n_s, wi) <= 0) {
				continue;
			}

			vec3 f = eval_bsdf(photon_eye_hit_mat, wo, wi, photon_eye_gbuffer.n_s, 1, eye_side);
			phi += f * photon_light.throughput * photon_eye.throughput;
			LOG_CLICKED3("(%d) - Path lengths: %d - %d\n", counter, eye_path_length, photon_path_length);
			counter++;
		}
		phi /= (PI * pc.photon_radius * pc.photon_radius * pc.num_photons);

		imageStore(caustics_texture, ivec2(gl_LaunchIDEXT.xy), vec4(phi, 1.f));
		if (counter > 0) {
			LOG_CLICKED("Num photons: %d\n", counter);
		}
		col = phi;
	}
	if (pc.enable_accumulation == 0 || pc.frame_num == 0) {
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
	} else {
		float w = 1. / float(pc.frame_num + 1);
		vec3 old_col = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_col, col, w), 1.f));
	}
}