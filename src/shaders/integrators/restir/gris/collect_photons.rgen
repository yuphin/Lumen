#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#define SCENE_TEX_IDX 8
#include "gris_commons.glsl"
layout(set = 1, binding = 1) uniform accelerationStructureEXT photon_bvh;

PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);

layout(binding = 4, std430) writeonly buffer OutReservoirs { Reservoir out_reservoirs[]; };
layout(binding = 5, std430) writeonly buffer OutGBuffer { GBuffer out_gbuffers[]; };
layout(binding = 6, rgba16) writeonly uniform image2D canonical_contributions_tex;
layout(binding = 7, rgba32f) uniform image2D caustics_texture;
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer PhotonEyeDataBuffer { PhotonEyeData d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer CausticPhotonAABBs { PhotonAABB d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer CausticPhotonLightData { PhotonLightData d[]; };
PhotonEyeDataBuffer photon_eye_data = PhotonEyeDataBuffer(scene_desc.photon_eye_addr);
CausticPhotonAABBs photon_aabbs = CausticPhotonAABBs(scene_desc.caustic_photon_aabbs_addr);
CausticPhotonLightData photon_light_data = CausticPhotonLightData(scene_desc.caustic_photon_light_addr);

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc.general_seed);
uvec4 sampling_seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc.sampling_seed);

bool photon_is_nearby(vec3 p, vec3 photon_p, float r) {
	vec3 diff = p - photon_p;
	return dot(diff, diff) < r * r;
}

vec3 get_center(PhotonAABB aabb) { return (aabb.min + aabb.max) * 0.5; }

void main() {
	PhotonEyeData photon_eye = photon_eye_data.d[pixel_idx];
	vec3 col = vec3(0);
	if (photon_eye.primitive_instance_id.x != -1) {
		HitData photon_eye_gbuffer = get_hitdata(photon_eye.barycentrics, photon_eye.primitive_instance_id.y,
												 photon_eye.primitive_instance_id.x);
		Material photon_eye_hit_mat = load_material(photon_eye_gbuffer.material_idx, photon_eye_gbuffer.uv);
		ASSERT(is_rough(photon_eye_hit_mat));

		rayQueryEXT ray_query;

		uint ray_flags = 0;
		rayQueryInitializeEXT(ray_query, photon_bvh, ray_flags, 0xFF, photon_eye_gbuffer.pos, 0, photon_eye_gbuffer.n_s,
							  1e-8);

		bool traverse = true;
		int counter = 0;

		vec3 phi = vec3(0);
		while (traverse) {
			traverse = rayQueryProceedEXT(ray_query);
			if (!traverse) {
				break;
			}

			int photon_idx = rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, false);

			// PhotonAABB photon_aabb = photon_aabbs.d[photon_idx];
			PhotonLightData photon_data = photon_light_data.d[photon_idx];

			HitData photon_hitdata = get_hitdata(photon_data.barycentrics, photon_data.primitive_instance_id.y,
												 photon_data.primitive_instance_id.x);

			bool photon_nearby = photon_is_nearby(photon_eye_gbuffer.pos, photon_hitdata.pos, pc.photon_radius);
			if (!photon_nearby) {
				continue;
			}

			uint side = photon_eye.side;
			vec3 wo = from_spherical(photon_eye.wo);
			vec3 wi = from_spherical(photon_data.wi);
			vec3 f = eval_bsdf(photon_eye_hit_mat, wo, wi, photon_eye_gbuffer.n_s, 1, side == 1);
			phi += f * photon_data.throughput * photon_eye.throughput;
			// LOG_CLICKED("AABB ID: %d\n", photon_idx);
			counter++;
		}
		// phi /= (PI * pc.photon_radius * pc.photon_radius * pc.num_photons);
		phi /= (PI * pc.photon_radius * pc.photon_radius * pc.num_photons);

		imageStore(caustics_texture, ivec2(gl_LaunchIDEXT.xy), vec4(phi, 1.f));
		LOG_CLICKED("Num photons: %d\n", counter);
		col = phi;
	}
	if (pc.enable_accumulation == 0 || pc.frame_num == 0) {
			imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
		} else {
			float w = 1. / float(pc.frame_num + 1);
			vec3 old_col = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
			imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_col, col, w), 1.f));
		}
}