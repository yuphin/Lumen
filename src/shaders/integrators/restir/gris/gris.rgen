#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#define SCENE_TEX_IDX 6
#include "gris_commons.glsl"

GrisDirectLighting direct_lighting_buffer = GrisDirectLighting(scene_desc.gris_direct_lighting_addr);
PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);

layout(binding = 4, std430) writeonly buffer OutReservoirs { Reservoir out_reservoirs[]; };
layout(binding = 5, std430) writeonly buffer OutGBuffer { GBuffer out_gbuffers[]; };

vec3 do_nee(inout uvec4 seed, HitData gbuffer, Material hit_mat, bool side, vec3 n_s, vec3 wo, out vec3 wi,
			out float pdf_light_w) {
	float wi_len;
	float pdf_light_a;
	LightRecord record;
	float cos_from_light;
	const vec3 Le = sample_light_Li(seed, gbuffer.pos, pc_ray.num_lights, pdf_light_w, wi, wi_len, pdf_light_a,
									cos_from_light, record);
	const vec3 p = offset_ray2(gbuffer.pos, n_s);
	float light_bsdf_pdf;
	float cos_x = dot(n_s, wi);
	vec3 f_light = eval_bsdf(n_s, wo, hit_mat, 1, side, wi, light_bsdf_pdf, cos_x);
	any_hit_payload.hit = 1;
	traceRayEXT(tlas, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xFF, 1, 0, 1, p, 0, wi,
				wi_len - EPS, 1);
	bool visible = any_hit_payload.hit == 0;

	const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
	if (visible && pdf_light_w > 0) {
		const float mis_weight = is_light_delta(record.flags) ? 1 : 1 / (1 + light_bsdf_pdf / pdf_light_w);
		return mis_weight * f_light * abs(cos_x) * Le / (pdf_light_w * light_pick_pdf);
	}
	return vec3(0);
}

uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.total_frame_num ^ pc_ray.random_num);

void main() {
	const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 in_uv = pixel / vec2(gl_LaunchSizeEXT.xy);
	vec2 d = in_uv * 2.0 - 1.0;
	vec4 origin = ubo.inv_view * vec4(0, 0, 0, 1);
	vec4 target = ubo.inv_projection * vec4(d.x, d.y, 1, 1);
	vec3 direction = vec3(sample_camera(d));
	vec3 col = vec3(0);

	GBuffer gbuffer_out;
	init_gbuffer(gbuffer_out);

	bool specular = false;
	vec3 partial_throughput = vec3(1);
	// Updated after a connectable vertex is found

	vec3 direct_lighting = vec3(0);
	float bsdf_pdf;

	// GRIS variables
	bool connectable_vertex_found = false;
	bool nee_streamed = false;
	bool prev_rough = false;
	bool curr_rough = false;
	uint init_seed;
	Reservoir reservoir;
	GrisData reconnection_data;
	init_reservoir(reservoir);
	init_data(reconnection_data);
	float joint_pdf = 1.0;
	vec3 postfix_L = vec3(0);
	vec3 postfix_throughput = vec3(1);
	float rc_pdf;
	float prefix_pdf;

	int depth;
	int postfix_depth = 0;
	int prefix_depth;

	vec3 prefix_col = vec3(0);
	for (depth = 0;; depth++) {
		traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, origin.xyz, tmin, direction, tmax, 0);
		const bool found_isect = payload.instance_idx != -1;
		if (depth >= pc_ray.max_depth - 1) {
			break;
		}
		if (!found_isect) {
			vec3 atmosphere_L = shade_atmosphere(pc_ray.dir_light_idx, pc_ray.sky_col, origin.xyz, direction, tmax);
			vec3 contrib = partial_throughput * atmosphere_L / joint_pdf;
			if (depth > 0) {
				col += contrib;
			} else if (pc_ray.direct_lighting == 1) {
				direct_lighting += contrib;
			}
			if (connectable_vertex_found) {
				postfix_L += postfix_throughput * atmosphere_L;
			}
			break;
		}

		float triangle_area = 0;
		HitData gbuffer = get_hitdata(payload.attribs, payload.instance_idx, payload.triangle_idx, triangle_area);
		const Material hit_mat = load_material(gbuffer.material_idx, gbuffer.uv);

		prev_rough = curr_rough;
		curr_rough = is_rough(hit_mat);
		// TODO: Check hit distance
		bool connectable = !connectable_vertex_found && ((prev_rough && curr_rough));

		const vec3 wo = -direction;
		vec3 n_s = gbuffer.n_s;
		vec3 n_g = gbuffer.n_g;

		bool side = face_forward(n_s, n_g, wo);

		// Fill in GBuffer
		if (depth == 0 && pc_ray.direct_lighting == 1) {
			direct_lighting += partial_throughput * hit_mat.emissive_factor / joint_pdf;

		} else if (depth > 0 && luminance(hit_mat.emissive_factor) > 0) {
			float mis_weight = 1.0;
			float pdf_light_w;
			if (!specular) {
				float g = abs(dot(-direction, n_s)) / (payload.dist * payload.dist);
				float pdf_light_w = 1.0 / (g * triangle_area);
				mis_weight = 1.0 / (1 + pdf_light_w / bsdf_pdf);
			}
			vec3 partial_contrib = mis_weight * hit_mat.emissive_factor;
			if (depth == 1) {
				if (pc_ray.direct_lighting == 1) {
					direct_lighting += partial_contrib * partial_throughput / joint_pdf;
				}
			} else {
				col += partial_contrib * partial_throughput / joint_pdf;
			}
			if (connectable_vertex_found) {
				postfix_L += partial_contrib * postfix_throughput;
			}
		}

		origin.xyz = offset_ray(gbuffer.pos, n_g);

		vec3 rc_Li = vec3(0);
		specular = (hit_mat.bsdf_props & BSDF_SPECULAR) != 0;
		// NEE
		if (!specular) {
			vec3 wi;
			float pdf_light;
			uint rc_seed = seed.w;
			vec3 Li = do_nee(seed, gbuffer, hit_mat, side, n_s, wo, wi, pdf_light);
			vec3 partial_contrib = partial_throughput * Li;
			vec3 contrib = partial_contrib / joint_pdf;

			// Stream the NEE path at the reconnection vertex
			if (connectable && !nee_streamed) {
				reconnection_data.rc_wi = wi;
				reconnection_data.rc_Li = Li;
				reconnection_data.reservoir_contribution = partial_contrib;
				reconnection_data.rc_seed = rc_seed;
				reconnection_data.path_flags = set_path_flags(depth, 1, true);
				stream_reservoir(seed, reservoir, reconnection_data,
								 calc_target_pdf(reconnection_data.reservoir_contribution), joint_pdf);
				nee_streamed = true;
				prefix_col = col;
			} else if (connectable_vertex_found) {
				postfix_L += Li * postfix_throughput;
			}

			if (depth > 0) {
				col += contrib;
			} else if (pc_ray.direct_lighting == 1) {
				direct_lighting += contrib;
			}
		}

		// Record initial seed after direct light sampling
		if (depth == 0) {
			init_seed = seed.w;
		}

		// Sample direction & update partial_throughput
		float cos_theta;
		const vec3 f = sample_bsdf(n_s, wo, hit_mat, 1 /*radiance=cam*/, side, direction, bsdf_pdf, cos_theta, seed);
		if (bsdf_pdf == 0) {
			break;
		}
		vec3 f_cos = f * abs(cos_theta);
		partial_throughput *= f_cos;
		joint_pdf *= bsdf_pdf;
		if (nee_streamed && connectable) {
			// Prepare reconnection data for the non-NEE path
			reconnection_data.rc_wi = direction;
			// Seed is not relevant here
			reconnection_data.rc_seed = -1;
			// Partially fill in the contribution data
			reconnection_data.reservoir_contribution = partial_throughput;
			rc_pdf = bsdf_pdf;
			prefix_pdf = joint_pdf / rc_pdf;
		}

		if (connectable_vertex_found) {
			postfix_throughput *= f_cos / bsdf_pdf;
			postfix_depth++;
		}

		if (connectable) {
			connectable_vertex_found = true;
			reconnection_data.rc_barycentrics = payload.attribs;
			reconnection_data.rc_primitive_instance_id = uvec2(payload.triangle_idx, payload.instance_idx);
			prefix_depth = depth;
		}

		if (pc_ray.enable_rr == 1) {
			float rr_scale = 1.0;
			if (hit_mat.bsdf_type == BSDF_GLASS) {
				rr_scale *= side ? 1. / hit_mat.ior : hit_mat.ior;
			}
			if (depth > RR_MIN_DEPTH) {
				float rr_prob = min(0.95f, luminance(partial_throughput / joint_pdf) * rr_scale);
				if (rr_prob == 0 || rr_prob < rand(seed))
					break;
				else
					partial_throughput /= rr_prob;
			}
		}
	}
	if (pc_ray.direct_lighting == 1) {
		direct_lighting_buffer.d[pixel_idx] = direct_lighting;
	}
	if (isnan(luminance(col))) {
		return;
	}
	// Stream the non-NEE path
	if (pc_ray.enable_gris == 1 && connectable_vertex_found) {
		reconnection_data.rc_Li = postfix_L;
		reconnection_data.reservoir_contribution = reconnection_data.reservoir_contribution * postfix_L;
		reconnection_data.path_flags = set_path_flags(prefix_depth, postfix_depth, false);
		stream_reservoir(seed, reservoir, reconnection_data, calc_target_pdf(reconnection_data.reservoir_contribution),
						 prefix_pdf * rc_pdf);
		calc_reservoir_W(reservoir);
		col = prefix_col + reservoir.data.reservoir_contribution * reservoir.W;
	}
	if(pc_ray.direct_lighting == 1) {
		col += direct_lighting;
	}

	if (pc_ray.frame_num > 0) {
		float w = 1. / float(pc_ray.frame_num + 1);
		vec3 old_col = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
		// imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_col, col, w), 1.f));
	} else {
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
	}
}