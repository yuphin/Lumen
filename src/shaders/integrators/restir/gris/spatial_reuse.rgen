#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#define SCENE_TEX_IDX 8
#include "gris_commons.glsl"
GrisDirectLighting direct_lighting_buffer = GrisDirectLighting(scene_desc.gris_direct_lighting_addr);
PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);
layout(binding = 4, std430) readonly buffer PathReconnections { ReconnectionData reconnection_data[]; };
layout(binding = 5, std430) readonly buffer InReservoirs { Reservoir in_reservoirs[]; };
layout(binding = 6, std430) writeonly buffer OutReservoirs { Reservoir out_reservoirs[]; };
layout(binding = 7, std430) readonly buffer CurrGBuffer { GBuffer curr_gbuffers[]; };
uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.total_frame_num ^ pc_ray.random_num);

ivec2 get_neighbor_offset(inout uvec4 seed) {
	const float randa = rand(seed) * PI2;
	const float randr = sqrt(rand(seed)) * pc_ray.spatial_radius;
	return ivec2(floor(cos(randa) * randr), floor(sin(randa) * randr));
}

bool process_reservoir(inout Reservoir reservoir, inout float m_c, in Reservoir canonical_reservoir,
					   in Reservoir source_reservoir, in ReconnectionData data, ivec2 neighbor_coords,
					   float canonical_in_canonical_pdf, out vec3 curr_reservoir_contribution) {
	const uint neighbor_pixel_idx = neighbor_coords.x * pc_ray.size_y + neighbor_coords.y;
	source_reservoir.M = min(source_reservoir.M, 20);
	
	float neighbor_in_neighbor_pdf = calc_target_pdf(source_reservoir.data.reservoir_contribution);
	float neighbor_in_canonical_pdf = calc_target_pdf(data.reservoir_contribution) * data.jacobian;
	const float m_i_num = source_reservoir.M * neighbor_in_neighbor_pdf;
	const float m_i_denom = m_i_num + canonical_reservoir.M * neighbor_in_canonical_pdf / pc_ray.num_spatial_samples;
	float m_i = m_i_denom == 0 ? 0 : m_i_num / m_i_denom;

	if (m_i <= 0.0 || m_i >= 1.0) {
		reservoir.M += source_reservoir.M;
		m_c += 1.0;
		return false;
	}

	const float m_c_num = source_reservoir.M * data.target_pdf_in_neighbor;
	const float m_c_denom = m_c_num + canonical_reservoir.M * canonical_in_canonical_pdf / pc_ray.num_spatial_samples;
	const float m_c_val = m_c_denom == 0.0 ? 0.0 : m_c_num / m_c_denom;
	if (m_c_val <= 0.0) {
		reservoir.M += source_reservoir.M;
		m_c += 1.0;
		return false;
	}
	m_c += 1.0 - m_c_val;
	ASSERT1(m_c_val > -EPS && m_c_val <= 1.001, "m_c_val <= 1.0 : %f\n", m_c_val);
	ASSERT1(m_i > -EPS && m_i <= 1.001, "m_i <= 1.0 : %f\n", m_i);
	bool accepted = combine_reservoir(seed, reservoir, source_reservoir, neighbor_in_canonical_pdf * m_i);
	if (accepted) {
		curr_reservoir_contribution = data.reservoir_contribution;
	}
	return accepted;
}

bool process_reservoir2(inout Reservoir reservoir, inout float m_c, in Reservoir canonical_reservoir,
					   in Reservoir source_reservoir, in ReconnectionData data, ivec2 neighbor_coords,
					   float canonical_in_canonical_pdf, out vec3 curr_reservoir_contribution) {
	const uint neighbor_pixel_idx = neighbor_coords.x * pc_ray.size_y + neighbor_coords.y;
	source_reservoir.M = min(source_reservoir.M, 20);
	
	float neighbor_in_neighbor_pdf = calc_target_pdf(source_reservoir.data.reservoir_contribution);
	float neighbor_in_canonical_pdf = calc_target_pdf(data.reservoir_contribution) * data.jacobian;
	const float m_i_num = source_reservoir.M * neighbor_in_neighbor_pdf;
	const float m_i_denom = m_i_num + canonical_reservoir.M * neighbor_in_canonical_pdf / pc_ray.num_spatial_samples;
	float m_i = m_i_denom == 0 ? 0 : m_i_num / m_i_denom;

	if (m_i <= 0.0 || m_i >= 1.0) {
		reservoir.M += source_reservoir.M;
		m_c += 1.0;
		return false;
	}

	const float m_c_num = source_reservoir.M * data.target_pdf_in_neighbor;
	const float m_c_denom = m_c_num + canonical_reservoir.M * canonical_in_canonical_pdf / pc_ray.num_spatial_samples;
	const float m_c_val = m_c_denom == 0.0 ? 0.0 : m_c_num / m_c_denom;
	if (m_c_val <= 0.0) {
		reservoir.M += source_reservoir.M;
		m_c += 1.0;
		return false;
	}
	m_c += 1.0 - m_c_val;
	ASSERT1(m_c_val > -EPS && m_c_val <= 1.001, "m_c_val <= 1.0 : %f\n", m_c_val);
	ASSERT1(m_i > -EPS && m_i <= 1.001, "m_i <= 1.0 : %f\n", m_i);
	bool accepted = combine_reservoir(seed, reservoir, source_reservoir, neighbor_in_canonical_pdf * m_i);
	if (accepted) {
		curr_reservoir_contribution = data.reservoir_contribution;
	}
	return accepted;
}

void main() {
	GBuffer gbuffer = curr_gbuffers[pixel_idx];
	if (!gbuffer_data_valid(gbuffer)) {
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(0));
		return;
	}

	Reservoir reservoir;
	init_reservoir(reservoir);

	Reservoir canonical_reservoir = in_reservoirs[pixel_idx];

	const vec3 canonical_reservoir_contribution = canonical_reservoir.data.reservoir_contribution;

	uint num_spatial_samples = pc_ray.enable_spatial_reuse == 1 ? pc_ray.num_spatial_samples : 0;
	vec3 curr_reservoir_contribution = canonical_reservoir_contribution;
	float m_c = 1.0;
	const float canonical_in_canonical_pdf = calc_target_pdf(canonical_reservoir_contribution);
	uint num_valid_samples = 0;

	uvec4 neighbor_seed = seed;
	for (uint i = 0; i < num_spatial_samples; i++) {
		ivec2 rand_offset = get_neighbor_offset(neighbor_seed);
		const ivec2 coords = ivec2(gl_LaunchIDEXT.xy) + rand_offset;
		const uint neighbor_pixel_idx = coords.x * pc_ray.size_y + coords.y;
		if (any(lessThan(coords, ivec2(0))) || any(greaterThanEqual(coords, gl_LaunchSizeEXT.xy))) {
			continue;
		}
		GBuffer neighbor_gbuffer = curr_gbuffers[neighbor_pixel_idx];
		if (!gbuffer_data_valid(neighbor_gbuffer)) {
			continue;
		}
		num_valid_samples++;

		const ReconnectionData data = reconnection_data[(num_spatial_samples + 1) * pixel_idx + i + 1];
		Reservoir neighbor_reservoir = in_reservoirs[neighbor_pixel_idx];
		process_reservoir(reservoir, m_c, canonical_reservoir, neighbor_reservoir, data, coords,
						  canonical_in_canonical_pdf, curr_reservoir_contribution);
	}
	bool canonical = combine_reservoir(seed, reservoir, canonical_reservoir, canonical_in_canonical_pdf * m_c);
	if (canonical) {
		curr_reservoir_contribution = canonical_reservoir_contribution;
	}
	const float target_pdf = calc_target_pdf(curr_reservoir_contribution);
	reservoir.W = target_pdf == 0.0 ? 0.0 : reservoir.w_sum / (target_pdf * (1 + num_valid_samples));
	// reservoir.W = target_pdf == 0.0 ? 0.0 : reservoir.w_sum / (target_pdf);

	vec3 final_contribution = prefix_contributions.d[pixel_idx];
	if (reservoir.W > 0) {
		final_contribution += curr_reservoir_contribution * reservoir.W;
	}

	out_reservoirs[pixel_idx] = reservoir;

	vec3 col = vec3(0);
	if (pc_ray.direct_lighting == 1) {
		col += direct_lighting_buffer.d[pixel_idx];
	}
	if (pc_ray.show_reconnection_radiance == 1) {
		col += reservoir.data.rc_postfix_L;
	} else {
		col += final_contribution;
	}

	ivec2 coords = ivec2(gl_LaunchIDEXT.xy);
	if (pc_ray.enable_accumulation == 0 || pc_ray.frame_num == 0) {
		imageStore(image, ivec2(coords), vec4(col, 1.f));
	} else {
		float w = 1. / float(pc_ray.frame_num + 1);
		vec3 old_col = imageLoad(image, ivec2(coords)).xyz;
		imageStore(image, ivec2(coords), vec4(mix(old_col, col, w), 1.f));
	}
}