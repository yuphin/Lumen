#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#include "../../commons.glsl"
layout(push_constant) uniform _PushConstantRay { PushConstantRay pc_ray; };
layout(buffer_reference, scalar) buffer RestirSamples { ReservoirSample d[]; };
layout(buffer_reference, scalar) buffer Reservoirs { Reservoir d[]; };
const uint flags = gl_RayFlagsOpaqueEXT;
const float tmin = 0.001;
const float tmax = 10000.0;
#define RR_MIN_DEPTH 3
uint pixel_idx = (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y);
uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.frame_num);
Reservoirs spatial_reservoirs = Reservoirs(scene_desc.spatial_reservoir_addr);
Reservoirs temp_reservoirs = Reservoirs(scene_desc.temporal_reservoir_addr);
RestirSamples samples = RestirSamples(scene_desc.restir_samples_addr);
#define M_MAX 500

void init_s(out ReservoirSample s) {
    s.x_v = vec3(0);
    s.n_v = vec3(0);
    s.x_s = vec3(0);
    s.n_s = vec3(0);
    s.L_o = vec3(0);
    s.f = vec3(0);
    s.p_q = 0;
}

void init_reservoir(out Reservoir r) {
    r.w_sum = 0;
    r.W = 0;
    r.m = 0;
    init_s(r.s);
}

void update_reservoir(inout Reservoir r, const ReservoirSample s, float w_i) {
    r.w_sum += w_i;
    r.m++;
    if (rand(seed) < w_i / r.w_sum) {
     
        r.s = s;
    } 
}

float p_hat(const vec3 f) { return length(f); }

void combine_reservoir(inout Reservoir r1, const Reservoir r2,
                        const ReservoirSample q, const ReservoirSample q_n,
                        out bool gt) {

    const uint r2_m = min(r2.m, M_MAX);
    float r2_hat = p_hat(r2.s.L_o);
    // // Check visibility
    any_hit_payload.hit = 1;
    vec3 wi = r2.s.x_s - q.x_v;
    const float wi_len = length(wi);
    wi /= wi_len;
    bool visible;
    if((q.bsdf_props & BSDF_TRANSMISSIVE) == 0) {
         traceRayEXT(tlas,
                gl_RayFlagsTerminateOnFirstHitEXT |
                    gl_RayFlagsSkipClosestHitShaderEXT,
                0xFF, 1, 0, 1, q.x_v, 0, wi, wi_len, 1);
    visible = any_hit_payload.hit == 0;
    } else {
        visible = q.p_q > 0;
    }
   
    if (!visible) {
        r2_hat = 0;
    } else {
        // Calculate Jacobian
        vec3 w_qq = q.x_v - q.x_s;
        const float w_qq_len = length(w_qq);
        w_qq /= w_qq_len;
        vec3 w_rq = r2.s.x_v - q.x_s;
        const float w_rq_len = length(w_rq);
        w_rq /= w_rq_len;
        const float qq = w_qq_len * w_qq_len;
        const float rq = w_rq_len * w_rq_len;
        const float div = rq * abs(dot(w_qq, q.n_s));
        const float j = div == 0 ? 0 : abs(dot(w_rq, q.n_s)) * qq / div;
        r2_hat *= j;
    }

    const float factor = r2_hat * r2_m * r2.W;
    gt = factor > 0;
    if (factor > 0) {
        update_reservoir(r1, r2.s, factor);
    }
}

uint offset(const uint pingpong) {
    return pingpong * pc_ray.size_x * pc_ray.size_y;
}

void main() {
    // TODO: Adaptively change this
    const uint pingpong = (pc_ray.frame_num % 2);
    const float max_r = 0.001;
    const float depth_threshold = 0.05;
    const float angle_threshold = 25 * PI / 180;
    ReservoirSample q = samples.d[pixel_idx];
    Reservoir r_s;
    // if (length(q.n_s) == 0) {
    //     return;
    // }
    if (pc_ray.do_spatiotemporal == 1) {
        r_s = spatial_reservoirs.d[offset(pingpong ^ 1) + pixel_idx];
    } else {
        init_reservoir(r_s);
    }

    const uint max_iter = r_s.m < M_MAX / 2 ? 9 : 3;
    uint Q[9] = uint[9](0, 0, 0, 0, 0, 0, 0, 0, 0);
    uint Q_h[9] = uint[9](0, 0, 0, 0, 0, 0, 0, 0, 0);
    uint q_cnt = 0;
    // if (pixel_idx == 212406) {
    //     debugPrintfEXT("%f\n",r_s.w_sum);
    // }
    Reservoir r;
    r.w_sum = 0;
    r.W = 0;
    r.m = 0;
    const float factor =
        pc_ray.do_spatiotemporal == 0 ? 0 : r_s.m * r_s.W * p_hat(r_s.s.L_o);
    if (factor > 0) {
        update_reservoir(r, r_s.s, factor);
    }
    uint Z = r_s.m;
    uint sum = r_s.m;
    ReservoirSample q_n;
    for (int i = 0; i < max_iter; i++) {
        // Choose a neighbor pixel
        const float randa = rand(seed) * 2 * PI;
        const float randr = rand(seed) * max_r;
        ivec2 rand_offset =
            ivec2(floor(cos(randa) * randr), floor(sin(randa * randr)));
        const ivec2 coords = clamp(ivec2(gl_LaunchIDEXT.xy) + rand_offset,
                                   ivec2(0), ivec2(gl_LaunchSizeEXT.xy) - 1);
        const uint coords_idx = coords.x * pc_ray.size_y + coords.y;

        // if (pixel_idx == 212406) {
        //     ivec2 loc_idx = ivec2(gl_LaunchIDEXT.xy);
        //     debugPrintfEXT("%v2i - %v2i\n", loc_idx, coords);
        // }
        q_n = samples.d[coords_idx];
        if (length(q_n.n_s) == 0) {
            // debugPrintfEXT("wh\n");
            continue;
        }
        // Geometric similarity
        const float l2_q = dot(q_n.x_v - q.x_v, q_n.x_v - q.x_v);
        const float l2_qn = dot(q.x_v, q.x_v);
        if (l2_q > depth_threshold * l2_qn ||
            ((dot(q_n.n_v, q.n_v)) < (cos(angle_threshold)))) {
            continue;
        }
        Reservoir r_n = temp_reservoirs.d[offset(pingpong ^ 1) + coords_idx];
        bool gt;
        combine_reservoir(r, r_n, q, q_n, gt);
        Q_h[q_cnt] = uint(gt);
        Q[q_cnt++] = r_n.m;
        sum += r_n.m;
    }
    const float phat_val = p_hat(r.s.L_o);
    if (phat_val > 0) {
        for (int i = 0; i < q_cnt; i++) {
            Z += Q[i];
        }
    }
    r.m = min(sum, M_MAX);
    r.W = Z * phat_val == 0 ? 0 : r.w_sum / (Z * phat_val);
    // if (pixel_idx == 212406) {
    //     debugPrintfEXT("%f: %f - %d - %f\n", r.W, r.w_sum, Z ,phat_val);
    // }

#define sr spatial_reservoirs.d[offset(pingpong) + pixel_idx]
    sr.w_sum = r.w_sum;
    sr.W = r.W;
    sr.m = r.m;
    sr.s = r.s;
}