#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_EXT_buffer_reference_uvec2 : enable
#extension GL_NV_shader_invocation_reorder : enable

#include "../../commons.glsl"
layout(push_constant) uniform _PushConstantRay { PushConstantRay pc_ray; };
const uint flags = gl_RayFlagsOpaqueEXT;
const float tmin = 0.001;
const float tmax = 10000.0;
#define RR_MIN_DEPTH 3
uint pixel_idx = (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y);
uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.frame_num);
#include "../pt_commons.glsl"

void main() {
#define JITTER 1
    const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
#if JITTER
    vec2 rands = vec2(rand(seed), rand(seed)) - 0.5;
    const vec2 in_uv = (pixel + rands) / vec2(gl_LaunchSizeEXT.xy);
#else
    const vec2 in_uv = (pixel) / vec2(gl_LaunchSizeEXT.xy);
#endif
    vec2 d = in_uv * 2.0 - 1.0;
    vec4 origin = ubo.inv_view * vec4(0, 0, 0, 1);
    vec4 target = ubo.inv_projection * vec4(d.x, d.y, 1, 1);
    vec3 direction = vec3(sample_camera(d));

    vec3 col = vec3(0);
    vec4 area_int = (ubo.inv_projection * vec4(2. / gl_LaunchSizeEXT.x,
                                               2. / gl_LaunchSizeEXT.y, 0, 1));
    area_int /= (area_int.w);
    const float cam_area = abs(area_int.x * area_int.y);
    bool specular = false;
    vec3 throughput = vec3(1);
    for (int depth = 0;; depth++) {
        hitObjectNV hit_obj;
        hitObjectTraceRayNV(hit_obj,
                   tlas,
                   flags,
                   0xFF,
                   0,
                   0,
                   0,
                   origin.xyz,
                   tmin,
                   direction,
                   tmax,
                   0);
 
        reorderThreadNV(hit_obj);
        const bool found_isect = hitObjectIsHitNV(hit_obj);
        if (depth >= pc_ray.max_depth - 1) {
            break;
        }
        if (!found_isect) {
            col += throughput * pc_ray.sky_col;
            break;
        }
        hitObjectExecuteShaderNV(hit_obj, 0);
        const Material hit_mat =
            load_material(payload.material_idx, payload.uv);
        if (depth == 0 || specular) {
            col += throughput * hit_mat.emissive_factor;
        }
        const vec3 wo = -direction;
        vec3 n_s = payload.n_s;
        bool side = true;
        vec3 n_g = payload.n_g;
        if (dot(payload.n_g, wo) < 0.)
            n_g = -n_g;
        if (dot(n_g, payload.n_s) < 0) {
            n_s = -n_s;
            side = false;
        }
        float cos_wo = dot(wo, n_s);
        origin.xyz = offset_ray(payload.pos, n_g);
        if ((hit_mat.bsdf_props & BSDF_SPECULAR) == 0) {
            const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
            col += throughput *
                   uniform_sample_light(hit_mat, payload.pos, side, n_s, wo,
                                        specular) /
                   light_pick_pdf;
        }
        // Sample direction & update throughput
        float pdf, cos_theta;
        const vec3 f = sample_bsdf(n_s, wo, hit_mat, 1 /*radiance=cam*/, side,
                                   direction, pdf, cos_theta, seed);
        if (pdf == 0) {
            break;
        }
        throughput *= f * abs(cos_theta) / pdf;
        specular = (hit_mat.bsdf_props & BSDF_SPECULAR) != 0;
        float rr_scale = 1.0;
        if (hit_mat.bsdf_type == BSDF_GLASS) {
            rr_scale *= side ? 1. / hit_mat.ior : hit_mat.ior;
        }
        if (depth > RR_MIN_DEPTH) {
            float rr_prob = min(0.95f, luminance(throughput) * rr_scale);
            if (rr_prob == 0 || rr_prob < rand(seed))
                break;
            else
                throughput /= rr_prob;
        }
    }
    if (isnan(luminance(col))) {
        return;
    }

    if (pc_ray.frame_num > 0) {

        float w = 1. / float(pc_ray.frame_num + 1);
        vec3 old_col = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        // imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
        imageStore(image, ivec2(gl_LaunchIDEXT.xy),
                   vec4(mix(old_col, col, w), 1.f));
    } else {

        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
    }
}