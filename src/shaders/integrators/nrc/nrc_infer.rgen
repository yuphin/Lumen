#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#include "../../commons.glsl"
#include "nrc_commons.h"

layout(location = 0) rayPayloadEXT HitPayload payload;
layout(location = 1) rayPayloadEXT AnyHitPayload any_hit_payload;
layout(push_constant) uniform _PushConstantRay { PCNRC pc_ray; };

const uint flags = gl_RayFlagsOpaqueEXT;
const float tmin = 0.001;
const float tmax = 10000.0;
#define RR_MIN_DEPTH 3
uint pixel_idx = (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y);
uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, pc_ray.frame_num ^ pc_ray.time);
#include "../pt_commons.glsl"

layout(buffer_reference, scalar, buffer_reference_align = 4) buffer InferenceQuery { RadianceQuery d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer InferenceRadiance { vec3 d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer Throughput { vec3 d[]; };

InferenceQuery inference_queries = InferenceQuery(scene_desc.inference_query_addr);
InferenceRadiance inference_radiance = InferenceRadiance(scene_desc.inference_radiance_addr);
Throughput throughput_buffer = Throughput(scene_desc.throughput_addr);

void get_polar(vec3 dir, out float phi, out float theta) {
	float y = min(max(dir.y, -1.0f), 1.0f);
	theta = acos(y);
	phi = atan(dir.y, dir.x);
}

void make_radiance_query(vec3 pos, vec3 normal, vec3 dir, float roughness, vec3 diffuse_reflectance,
						 vec3 specular_reflectance, out RadianceQuery radiance_query) {
	radiance_query.position = (pos - pc_ray.min_bounds) / (pc_ray.max_bounds - pc_ray.min_bounds);
	get_polar(normal, radiance_query.normal_phi, radiance_query.normal_theta);
	get_polar(dir, radiance_query.dir_phi, radiance_query.dir_theta);
	radiance_query.roughness = roughness;
	radiance_query.diffuse_reflectance = diffuse_reflectance;
	radiance_query.specular_reflectance = specular_reflectance;
}

void main() {
#define JITTER 1
	const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
#if JITTER
	vec2 rands = vec2(rand(seed), rand(seed)) - 0.5;
	const vec2 in_uv = (pixel + rands) / vec2(gl_LaunchSizeEXT.xy);
#else
	const vec2 in_uv = (pixel) / vec2(gl_LaunchSizeEXT.xy);
#endif
	vec2 d = in_uv * 2.0 - 1.0;
	vec4 origin = ubo.inv_view * vec4(0, 0, 0, 1);
	vec4 target = ubo.inv_projection * vec4(d.x, d.y, 1, 1);
	vec3 direction = vec3(sample_camera(d));

	vec3 col = vec3(0);
	vec4 area_int = (ubo.inv_projection * vec4(2. / gl_LaunchSizeEXT.x, 2. / gl_LaunchSizeEXT.y, 0, 1));
	area_int /= (area_int.w);
	const float cam_area = abs(area_int.x * area_int.y);
	bool specular = false;
	vec3 throughput = vec3(1);
	for (int depth = 0;; depth++) {
		traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, origin.xyz, tmin, direction, tmax, 0);
		const bool found_isect = payload.material_idx != -1;

		if (!found_isect) {
			col += throughput * shade_atmosphere(pc_ray.dir_light_idx, pc_ray.sky_col, origin.xyz, direction, tmax);
			break;
		}

		const Material hit_mat = load_material(payload.material_idx, payload.uv);
		if (depth == 0 || specular) {
			col += throughput * hit_mat.emissive_factor;
		}
		const vec3 wo = -direction;
		vec3 n_s = payload.n_s;
		bool side = true;
		vec3 n_g = payload.n_g;
		if (dot(payload.n_g, wo) < 0.) n_g = -n_g;
		if (dot(n_g, payload.n_s) < 0) {
			n_s = -n_s;
			side = false;
		}
		float cos_wo = dot(wo, n_s);
		origin.xyz = offset_ray(payload.pos, n_g);
		if ((hit_mat.bsdf_props & BSDF_SPECULAR) == 0) {
			const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
            if(depth > 0) {
                // col +=
                //     throughput * uniform_sample_light(seed, hit_mat, payload.pos, side, n_s, wo, specular) / light_pick_pdf;
            }
		}
		// Sample direction & update throughput
		float pdf, cos_theta;
		const vec3 f = sample_bsdf(n_s, wo, hit_mat, 1 /*radiance=cam*/, side, direction, pdf, cos_theta, seed);
		if (pdf == 0) {
			break;
		}
		throughput *= f * abs(cos_theta) / pdf;
		specular = (hit_mat.bsdf_props & BSDF_SPECULAR) != 0;
		float rr_scale = 1.0;
		if (hit_mat.bsdf_type == BSDF_GLASS) {
			rr_scale *= side ? 1. / hit_mat.ior : hit_mat.ior;
		}
		if (depth > RR_MIN_DEPTH) {
			float rr_prob = min(0.95f, luminance(throughput) * rr_scale);
			if (rr_prob == 0 || rr_prob < rand(seed))
				break;
			else
				throughput /= rr_prob;
		}
		if (depth >= pc_ray.max_depth - 1) {
			break;
		}

		if (depth == 1) {
            RadianceQuery query;
			make_radiance_query(payload.pos, n_s, direction, 1.0, hit_mat.albedo, vec3(0), query);
			inference_queries.d[pixel_idx] = query;
            throughput_buffer.d[pixel_idx] = throughput;
            // Break at query position for now
            break; 
		}
	}

	if (isnan(luminance(col))) {
		return;
	}
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
}