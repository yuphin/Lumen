#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#include "nrc_commons.h"
#include "../../utils.glsl"
layout(push_constant) uniform _PushConstantRay { PCNRC pc_ray; };
uvec4 seed = init_rng(gl_GlobalInvocationID.xy, uvec2(0), pc_ray.frame_num);

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(buffer_reference, scalar, buffer_reference_align = 4) buffer SampleCount { uint d; };
layout(binding = 0) buffer SceneDesc_ { SceneDesc scene_desc; };
layout(binding = 1) readonly buffer InferenceRadiance { vec3 inference_radiance[]; };
layout(binding = 2, rgba32f) uniform image2D image;

SampleCount sample_count = SampleCount(scene_desc.sample_count_addr);

layout(buffer_reference, scalar, buffer_reference_align = 4) buffer InferenceRadianceA { vec3 d[]; };
InferenceRadianceA inference_radiance_a = InferenceRadianceA(scene_desc.inference_radiance_addr);


void main() {
	uint in_idx = gl_GlobalInvocationID.x;

	ivec2 coords = ivec2(gl_GlobalInvocationID.x / pc_ray.size_y, gl_GlobalInvocationID.x % pc_ray.size_y);
	if (in_idx >= pc_ray.size_x * pc_ray.size_y) {
		return;
	}

    // vec3 col = inference_radiance_a.d[in_idx];
    // if (pc_ray.frame_num > 0) {
    //     float w = 1. / float(pc_ray.frame_num + 1);

    //     vec3 old_col = imageLoad(image, ivec2(coords)).xyz;
    //     imageStore(image, ivec2(coords), vec4(mix(old_col, col, w), 1.f));
    // } else {
    //     imageStore(image, ivec2(coords), vec4(col, 1.f));
    // }

    // vec3 inference_L = inference_radiance[in_idx];
    vec3 inference_L = inference_radiance_a.d[in_idx];
    imageStore(image, ivec2(coords), vec4(inference_L, 1.f));
}