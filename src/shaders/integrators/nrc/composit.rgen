#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#include "nrc_commons.h"
layout(push_constant) uniform _PushConstantRay { PCNRC pc_ray; };
#include "../restir/di/restirdi_commons.glsl"

layout(buffer_reference, scalar, buffer_reference_align = 4) buffer InferenceRadiance { vec3 d[]; };
layout(buffer_reference, scalar, buffer_reference_align = 4) buffer Throughput { vec3 d[]; };
InferenceRadiance inference_radiance = InferenceRadiance(scene_desc.inference_radiance_addr);
Throughput throughput_buffer = Throughput(scene_desc.throughput_addr);


void main() {
	load_g_buffer();
	vec3 col = vec3(0);
	const RestirReservoir r = spatial_reservoirs.d[pixel_idx];
	if (isnan(luminance(col))) {
		return;
	}
	if (r.W > 0) {
		col += r.W * calc_L_with_visibility_check(r) * pc_ray.light_triangle_count;
		temporal_reservoirs.d[pixel_idx].w_sum = r.w_sum;
		temporal_reservoirs.d[pixel_idx].W = r.W;
		temporal_reservoirs.d[pixel_idx].m = r.m;
		temporal_reservoirs.d[pixel_idx].s = r.s;
	}
	// if (pc_ray.frame_num == 0) {
	// 	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
	// } else {
	// 	float w = 1. / float(pc_ray.frame_num + 1);
	// 	vec3 old_col = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
	// 	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_col, col, w), 1.f));
	// }
    uint in_idx = (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y);
    vec3 direct_L = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
    vec3 inference_L = inference_radiance.d[in_idx];
    col += direct_L + throughput_buffer.d[in_idx] * inference_L;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
}